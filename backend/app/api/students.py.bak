"""
Student API endpoints for managing student data, groups, and face embeddings
"""
from flask import Blueprint, request, jsonify, current_app
from werkzeug.utils import secure_filename
from app.models.student import Student
from app.models.group import Group
from app import db
from app.services.face_service import FaceService
from app.services.drive_service import DriveService
from app.utils.auth import admin_required
import os
import uuid
import tempfile
import io
import csv
import cv2
import numpy as np

student_bp = Blueprint('students', __name__)
face_service = FaceService()
drive_service = DriveService()

def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in {'png', 'jpg', 'jpeg'}
           
def allowed_bulk_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in {'csv'}

# Get all students
@student_bp.route('/', methods=['GET'])
@admin_required()
def get_all_students():
    """Get all students"""
    try:
        students = Student.query.all()
        return jsonify({"students": [student.to_dict() for student in students]}), 200
    except Exception as e:
        current_app.logger.error(f"Error fetching all students: {str(e)}")
        return jsonify({"error": "An unexpected error occurred"}), 500

# Register a new student (legacy API)
@student_bp.route('/register', methods=['POST'])
@admin_required()
def register_student():
    """Register a new student with photo"""
    try:
        # Check if the request has the required fields
        if 'student_id' not in request.form or 'name' not in request.form:
            return jsonify({"error": "Missing required fields"}), 400
            
        student_id = request.form['student_id']
        name = request.form['name']
        
        # Check if student already exists
        existing_student = Student.query.filter_by(student_id=student_id).first()
        if existing_student:
            return jsonify({"error": f"Student with ID {student_id} already exists"}), 409
            
        # Create new student with basic info first
        new_student = Student(
            student_id=student_id,
            name=name,
            group_id=None,  # No group for direct registration
            photo_path=None
        )
        
        # Handle image file if present
        if 'image' in request.files:
            file = request.files['image']
            if file and allowed_file(file.filename):
                # Generate a unique filename with UUID
                filename = f"{student_id}_{str(uuid.uuid4())}.jpg"
                filepath = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
                
                # Save the file
                file.save(filepath)
                
                # Update photo path
                new_student.photo_path = filepath
                
                # Process face embedding
                try:
                    # Read the image
                    img = cv2.imread(filepath)
                    if img is None:
                        current_app.logger.warning(f"Failed to read image file for student {student_id}")
                    else:
                        # Detect face and get embedding
                        bbox, embedding = face_service.detect_and_embed_face(img)
                        
                        if embedding is None:
                            current_app.logger.warning(f"No face detected in image for student {student_id}")
                        else:
                            # Store the embedding with the student
                            new_student.set_embedding(embedding)
                except Exception as e:
                    current_app.logger.error(f"Error processing face: {str(e)}")
                    # Continue without embedding - it's nullable now
        
        # Handle Drive link if present
        elif 'drive_link' in request.form and request.form['drive_link']:
            drive_link = request.form['drive_link']
            
            try:
                # Download image from drive and process
                temp_filepath = drive_service.download_file(drive_link)
                
                # Generate a unique filename with UUID
                filename = f"{student_id}_{str(uuid.uuid4())}.jpg"
                filepath = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
                
                # Copy the temp file to uploads
                import shutil
                shutil.copy(temp_filepath, filepath)
                
                # Clean up temp file
                os.remove(temp_filepath)
                
                # Update photo path
                new_student.photo_path = filepath
                
                # Process face embedding
                try:
                    # Read the image
                    img = cv2.imread(filepath)
                    if img is None:
                        current_app.logger.warning(f"Failed to read image file from Drive for student {student_id}")
                    else:
                        # Detect face and get embedding
                        bbox, embedding = face_service.detect_and_embed_face(img)
                        
                        if embedding is None:
                            current_app.logger.warning(f"No face detected in image from Drive for student {student_id}")
                        else:
                            # Store the embedding with the student
                            new_student.set_embedding(embedding)
                except Exception as e:
                    current_app.logger.error(f"Error processing face from Drive: {str(e)}")
                    # Continue without embedding - it's nullable now
            except Exception as e:
                current_app.logger.error(f"Error downloading from drive: {str(e)}")
                return jsonify({"error": "Could not process image from Drive link"}), 400
        
        # Save the student to the database
        db.session.add(new_student)
        db.session.commit()
        
        return jsonify({"message": "Student registered successfully", "student": new_student.to_dict()}), 201
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error registering student: {str(e)}")
        import traceback
        tb = traceback.format_exc()
        current_app.logger.error(tb)
        
        # Provide more specific error messages based on the exception
        if 'duplicate key' in str(e).lower():
            return jsonify({"error": f"Student with ID {student_id} already exists"}), 409
        elif 'drive' in str(e).lower() or 'google' in str(e).lower():
            return jsonify({"error": f"Google Drive error: {str(e)}. Try uploading a local image instead."}), 400
        elif 'permission' in str(e).lower():
            return jsonify({"error": "Permission error with Google Drive. Make sure the file is shared with the service account."}), 403
        elif 'not found' in str(e).lower() or '404' in str(e):
            return jsonify({"error": "File not found on Google Drive. Check the link and try again."}), 404
        elif 'file' in str(e).lower() or 'directory' in str(e).lower():
            return jsonify({"error": f"File system error: {str(e)}. Check if uploads directory exists and is writable."}), 500
        else:
            return jsonify({
                "error": "An unexpected error occurred",
                "details": str(e)
            }), 500

# This endpoint is commented out because it's now handled in groups.py
# to prevent endpoint conflicts with get_students_by_group
# @student_bp.route('/groups/<int:group_id>/students', methods=['GET'])
# @admin_required()
# def get_students_by_group(group_id):
#     """Get all students in a group"""
#     # Moved to groups.py

# Delete a student
@student_bp.route('/<string:student_id>', methods=['DELETE'])
@admin_required()
def delete_student(student_id):
    """Delete a student by ID"""
    try:
        # Log the request
        current_app.logger.info(f"Deleting student with ID: {student_id}")
        
        # Find the student
        student = Student.query.get(student_id)
        if not student:
            current_app.logger.warning(f"Student with ID {student_id} not found")
            return jsonify({"error": f"Student with ID {student_id} not found"}), 404
        
        # Delete the student's photo if it exists
        if student.photo_path and os.path.exists(student.photo_path):
            try:
                os.remove(student.photo_path)
                current_app.logger.info(f"Deleted photo file: {student.photo_path}")
            except Exception as e:
                current_app.logger.warning(f"Could not delete photo file: {str(e)}")
                # Continue with deletion even if photo can't be removed
        
        # Delete the student from the database
        db.session.delete(student)
        db.session.commit()
        
        current_app.logger.info(f"Successfully deleted student with ID: {student_id}")
        return jsonify({"message": f"Student with ID {student_id} has been deleted"}), 200
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error deleting student: {str(e)}")
        import traceback
        tb = traceback.format_exc()
        current_app.logger.error(tb)
        return jsonify({"error": "An unexpected error occurred", "details": str(e)}), 500

# Register a new student (legacy API)
@student_bp.route('/register', methods=['POST'])
@admin_required()
def register_student():
    """Register a new student with photo"""
    try:
        # Check if the request has the required fields
        if 'student_id' not in request.form or 'name' not in request.form:
            return jsonify({"error": "Missing required fields"}), 400
            
        student_id = request.form['student_id']
        name = request.form['name']
        
        # Check if student already exists
        existing_student = Student.query.filter_by(student_id=student_id).first()
        if existing_student:
            return jsonify({"error": f"Student with ID {student_id} already exists"}), 409
            
        # Create new student with basic info first
        new_student = Student(
            student_id=student_id,
            name=name,
            group_id=None,  # No group for direct registration
            photo_path=None
        )
        
        # Handle image file if present
        if 'image' in request.files:
            file = request.files['image']
            if file and allowed_file(file.filename):
                # Generate a unique filename with UUID
                filename = f"{student_id}_{str(uuid.uuid4())}.jpg"
                filepath = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
                
                # Save the file
                file.save(filepath)
                
                # Update photo path
                new_student.photo_path = filepath
                
                # Process face embedding
                try:
                    # Read the image
                    img = cv2.imread(filepath)
                    if img is None:
                        current_app.logger.warning(f"Failed to read image file for student {student_id}")
                    else:
                        # Detect face and get embedding
                        bbox, embedding = face_service.detect_and_embed_face(img)
                        
                        if embedding is None:
                            current_app.logger.warning(f"No face detected in image for student {student_id}")
                        else:
                            # Store the embedding with the student
                            new_student.set_embedding(embedding)
                except Exception as e:
                    current_app.logger.error(f"Error processing face: {str(e)}")
                    # Continue without embedding - it's nullable now
        
        # Handle Drive link if present
        elif 'drive_link' in request.form and request.form['drive_link']:
            drive_link = request.form['drive_link']
            
            try:
                # Download image from drive and process
                temp_filepath = drive_service.download_file(drive_link)
                
                # Generate a unique filename with UUID
                filename = f"{student_id}_{str(uuid.uuid4())}.jpg"
                filepath = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
                
                # Copy the temp file to uploads
                import shutil
                shutil.copy(temp_filepath, filepath)
                
                # Clean up temp file
                os.remove(temp_filepath)
                
                # Update photo path
                new_student.photo_path = filepath
                
                # Process face embedding
                try:
                    # Read the image
                    img = cv2.imread(filepath)
                    if img is None:
                        current_app.logger.warning(f"Failed to read image file from Drive for student {student_id}")
                    else:
                        # Detect face and get embedding
                        bbox, embedding = face_service.detect_and_embed_face(img)
                        
                        if embedding is None:
                            current_app.logger.warning(f"No face detected in image from Drive for student {student_id}")
                        else:
                            # Store the embedding with the student
                            new_student.set_embedding(embedding)
                except Exception as e:
                    current_app.logger.error(f"Error processing face from Drive: {str(e)}")
                    # Continue without embedding - it's nullable now
            except Exception as e:
                current_app.logger.error(f"Error downloading from drive: {str(e)}")
                return jsonify({"error": "Could not process image from Drive link"}), 400
        
        # Save the student to the database
        db.session.add(new_student)
        db.session.commit()
        
        return jsonify({"message": "Student registered successfully", "student": new_student.to_dict()}), 201
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error registering student: {str(e)}")
        import traceback
        tb = traceback.format_exc()
        current_app.logger.error(tb)
        
        # Provide more specific error messages based on the exception
        if 'duplicate key' in str(e).lower():
            return jsonify({"error": f"Student with ID {student_id} already exists"}), 409
        elif 'drive' in str(e).lower() or 'google' in str(e).lower():
            return jsonify({"error": f"Google Drive error: {str(e)}. Try uploading a local image instead."}), 400
        elif 'permission' in str(e).lower():
            return jsonify({"error": "Permission error with Google Drive. Make sure the file is shared with the service account."}), 403
        elif 'not found' in str(e).lower() or '404' in str(e):
            return jsonify({"error": "File not found on Google Drive. Check the link and try again."}), 404
        elif 'file' in str(e).lower() or 'directory' in str(e).lower():
            return jsonify({"error": f"File system error: {str(e)}. Check if uploads directory exists and is writable."}), 500
        else:
            return jsonify({
                "error": "An unexpected error occurred",
                "details": str(e)
            }), 500

@student_bp.route('/groups/<int:group_id>/students', methods=['GET'])
@admin_required()
def get_students_by_group(group_id):
    """Get all students in a group"""
    try:
        # Log the request
        current_app.logger.info(f"Fetching students for group {group_id}")
        
        # Check if group exists
        group = Group.query.get(group_id)
        if not group:
            current_app.logger.warning(f"Group with ID {group_id} not found")
            return jsonify({"error": f"Group with ID {group_id} not found"}), 404
        
        # Skip face service initialization
        # This is where errors occur if the face recognition model has issues
        
        # Get students - log how many we found
        students = Student.query.filter_by(group_id=group_id).all()
        current_app.logger.info(f"Found {len(students)} students for group {group_id}")
        
        # Manually construct student dicts to avoid any potential errors
        student_dicts = []
        for student in students:
            try:
                student_dict = {
                    'student_id': student.student_id,
                    'name': student.name,
                    'group_id': student.group_id,
                    'created_at': student.created_at.isoformat() if student.created_at else None
                }
                
                # Safely add photo_url if it exists
                if hasattr(student, 'photo_path') and student.photo_path:
                    try:
                        student_dict['photo_url'] = f"/uploads/{os.path.basename(student.photo_path)}"
                    except Exception as e:
                        current_app.logger.error(f"Error processing photo path for student {student.student_id}: {str(e)}")
                        student_dict['photo_url'] = None
                else:
                    student_dict['photo_url'] = None
                
                student_dicts.append(student_dict)
            except Exception as e:
                current_app.logger.error(f"Error processing student {student.student_id}: {str(e)}")
                # Continue processing other students
                continue
        
        response_data = {
            "group": {
                'id': group.id,
                'name': group.name,
                'student_count': len(students)
            },
            "students": student_dicts
        }
        
        return jsonify(response_data), 200
    except Exception as e:
        current_app.logger.error(f"Error fetching students for group {group_id}: {str(e)}")
        import traceback
        current_app.logger.error(traceback.format_exc())
        return jsonify({"error": "An unexpected error occurred", "details": str(e)}), 500

# Delete a student
@student_bp.route('/<string:student_id>', methods=['DELETE'])
@admin_required()
def delete_student(student_id):
    """Delete a student by ID"""
    try:
        # Log the request
        current_app.logger.info(f"Deleting student with ID: {student_id}")
        
        # Find the student
        student = Student.query.get(student_id)
        if not student:
            current_app.logger.warning(f"Student with ID {student_id} not found")
            return jsonify({"error": f"Student with ID {student_id} not found"}), 404
        
        # Delete the student's photo if it exists
        if student.photo_path and os.path.exists(student.photo_path):
            try:
                os.remove(student.photo_path)
                current_app.logger.info(f"Deleted photo file: {student.photo_path}")
            except Exception as e:
                current_app.logger.warning(f"Could not delete photo file: {str(e)}")
                # Continue with deletion even if photo can't be removed
        
        # Delete the student from the database
        db.session.delete(student)
        db.session.commit()
        
        current_app.logger.info(f"Successfully deleted student with ID: {student_id}")
        return jsonify({"message": f"Student with ID {student_id} has been deleted"}), 200
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error deleting student: {str(e)}")
        import traceback
        tb = traceback.format_exc()
        current_app.logger.error(tb)
        return jsonify({"error": "An unexpected error occurred", "details": str(e)}), 500
        if 'student_id' not in request.form or 'name' not in request.form:
            return jsonify({"error": "Missing required fields"}), 400
            
        student_id = request.form['student_id']
        name = request.form['name']
        
        # Check if student already exists
        existing_student = Student.query.filter_by(student_id=student_id).first()
        if existing_student:
            return jsonify({"error": f"Student with ID {student_id} already exists"}), 409
            
        # Create new student with basic info first
        new_student = Student(
            student_id=student_id,
            name=name,
            group_id=None,  # No group for direct registration
            photo_path=None
        )
        
        # Handle image file if present
        if 'image' in request.files:
            file = request.files['image']
            if file and allowed_file(file.filename):
                # Generate a unique filename with UUID
                filename = f"{student_id}_{str(uuid.uuid4())}.jpg"
                filepath = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
                
                # Save the file
                file.save(filepath)
                
                # Update photo path
                new_student.photo_path = filepath
                
                # Process face embedding
                try:
                    # Read the image
                    img = cv2.imread(filepath)
                    if img is None:
                        return jsonify({"error": "Failed to read image file"}), 400
                    
                    # Detect face and get embedding
                    bbox, embedding = face_service.detect_and_embed_face(img)
                    
                    if embedding is None:
                        current_app.logger.warning(f"No face detected in image for student {student_id}")
                    else:
                        # Store the embedding with the student
                        new_student.set_embedding(embedding)
                except Exception as e:
                    current_app.logger.error(f"Error processing face: {str(e)}")
                    # Continue without embedding - it's nullable now
        
        # Save the student to the database
        db.session.add(new_student)
        db.session.commit()
        
        return jsonify({"message": "Student registered successfully", "student": new_student.to_dict()}), 201
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error registering student: {str(e)}")
        import traceback
        tb = traceback.format_exc()
        current_app.logger.error(tb)
        
        # Provide more specific error messages based on the exception
        if 'duplicate key' in str(e).lower():
            return jsonify({"error": f"Student with ID {student_id} already exists"}), 409
        elif 'drive' in str(e).lower() or 'google' in str(e).lower():
            return jsonify({"error": f"Google Drive error: {str(e)}. Try uploading a local image instead."}), 400
        elif 'permission' in str(e).lower():
            return jsonify({"error": "Permission error with Google Drive. Make sure the file is shared with the service account."}), 403
        elif 'not found' in str(e).lower() or '404' in str(e):
            return jsonify({"error": "File not found on Google Drive. Check the link and try again."}), 404
        elif 'file' in str(e).lower() or 'directory' in str(e).lower():
            return jsonify({"error": f"File system error: {str(e)}. Check if uploads directory exists and is writable."}), 500
        else:
            return jsonify({
                "error": "An unexpected error occurred",
                "details": str(e)
            }), 500
        
        # Handle image file if present
        if 'image' in request.files:
            file = request.files['image']
            if file and allowed_file(file.filename):
                # Generate a unique filename with UUID
                filename = f"{student_id}_{str(uuid.uuid4())}.jpg"
                filepath = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
                
                # Save the file
                file.save(filepath)
                
                # Update photo path
                new_student.photo_path = filepath
                
                # Process face embedding
                try:
                    # Read the image
                    img = cv2.imread(filepath)
                    if img is None:
                        current_app.logger.warning(f"Failed to read image file for student {student_id}")
                    else:
                        # Detect face and get embedding
                        bbox, embedding = face_service.detect_and_embed_face(img)
                        
                        if embedding is None:
                            current_app.logger.warning(f"No face detected in image for student {student_id}")
                        else:
                            # Store the embedding with the student
                            new_student.set_embedding(embedding)
                except Exception as e:
                    current_app.logger.error(f"Error processing face: {str(e)}")
                    # Continue without embedding - it's nullable now
        
        # Handle Drive link if present
        elif 'drive_link' in request.form and request.form['drive_link']:
            drive_link = request.form['drive_link']
            
            try:
                # Download image from drive and process
                temp_filepath = drive_service.download_file(drive_link)
                
                # Generate a unique filename with UUID
                filename = f"{student_id}_{str(uuid.uuid4())}.jpg"
                filepath = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
                
                # Copy the temp file to uploads
                import shutil
                shutil.copy(temp_filepath, filepath)
                
                # Clean up temp file
                os.remove(temp_filepath)
                
                # Update photo path
                new_student.photo_path = filepath
                
                # Process face embedding
                try:
                    # Read the image
                    img = cv2.imread(filepath)
                    if img is None:
                        current_app.logger.warning(f"Failed to read image file from Drive for student {student_id}")
                    else:
                        # Detect face and get embedding
                        bbox, embedding = face_service.detect_and_embed_face(img)
                        
                        if embedding is None:
                            current_app.logger.warning(f"No face detected in image from Drive for student {student_id}")
                        else:
                            # Store the embedding with the student
                            new_student.set_embedding(embedding)
                except Exception as e:
                    current_app.logger.error(f"Error processing face from Drive: {str(e)}")
                    # Continue without embedding - it's nullable now
            except Exception as e:
                current_app.logger.error(f"Error downloading from drive: {str(e)}")
                return jsonify({"error": "Could not process image from Drive link"}), 400
        
        # Save the student to the database
        db.session.add(new_student)
        # Save the student to the database
        db.session.add(new_student)
        db.session.commit()
        
        return jsonify({"message": "Student registered successfully", "student": new_student.to_dict()}), 201
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error registering student: {str(e)}")
        import traceback
        tb = traceback.format_exc()
        current_app.logger.error(tb)
        
        # Provide more specific error messages based on the exception
        if 'duplicate key' in str(e).lower():
            return jsonify({"error": f"Student with ID {student_id} already exists"}), 409
        elif 'drive' in str(e).lower() or 'google' in str(e).lower():
            return jsonify({"error": f"Google Drive error: {str(e)}. Try uploading a local image instead."}), 400
        elif 'permission' in str(e).lower():
            return jsonify({"error": "Permission error with Google Drive. Make sure the file is shared with the service account."}), 403
        elif 'not found' in str(e).lower() or '404' in str(e):
            return jsonify({"error": "File not found on Google Drive. Check the link and try again."}), 404
        elif 'file' in str(e).lower() or 'directory' in str(e).lower():
            return jsonify({"error": f"File system error: {str(e)}. Check if uploads directory exists and is writable."}), 500
        else:
            return jsonify({
                "error": "An unexpected error occurred",
                "details": str(e)
            }), 500
        
        if 'file' not in request.files:
            return jsonify({"success": False, "message": "No file provided"}), 400
        
        file = request.files['file']
        if file.filename == '':
            return jsonify({"success": False, "message": "No file selected"}), 400
        
        if not allowed_bulk_file(file.filename):
            return jsonify({
                "success": False, 
                "message": "Only CSV accepted. File must include header: student_id,name,drive_link"
            }), 400
        
        # Process the CSV file
        try:
            # Read the CSV file
            stream = io.StringIO(file.stream.read().decode("UTF8"), newline=None)
            csv_reader = csv.reader(stream)
            
            # Check header
            try:
                header = next(csv_reader)
            except StopIteration:
                return jsonify({
                    "success": False,
                    "message": "CSV file is empty"
                }), 400
                
            # Normalize header by stripping whitespace and lowercasing
            header = [col.strip().lower() for col in header]
            
            # Define variations of required column names
            student_id_variations = ['student_id', 'student id', 'studentid', 'id', 'your college id', 'college id']
            name_variations = ['name', 'full name', 'student name', 'your name']
            drive_link_variations = ['drive_link', 'drive link', 'drivelink', 'photo', 'image', 'upload your clear image']
            
            # Find matching columns
            student_id_col = next((col for col in header if col in student_id_variations), None)
            name_col = next((col for col in header if col in name_variations), None)
            drive_link_col = next((col for col in header if col in drive_link_variations), None)
            
            missing_columns = []
            if not student_id_col:
                missing_columns.append('student_id')
            if not name_col:
                missing_columns.append('name')
            if not drive_link_col:
                missing_columns.append('drive_link')
            
            if missing_columns:
                return jsonify({
                    "success": False,
                    "message": f"Missing required columns: {', '.join(missing_columns)}. File must include: student_id,name,drive_link"
                }), 400
            
            # Get indexes for each column
            student_id_idx = header.index(student_id_col)
            name_idx = header.index(name_col)
            drive_link_idx = header.index(drive_link_col)
            
            # Process each row
            successes = []
            failures = []
            
            for row_idx, row in enumerate(csv_reader, start=1):  # Start from 1 for human-readable row numbers
                if not row or len(row) < max(student_id_idx, name_idx, drive_link_idx) + 1:
                    failures.append({
                        "row": row_idx,
                        "student_id": "",
                        "reason_code": "invalid_format",
                        "message": "Row has fewer columns than expected"
                    })
                    continue
                    
                student_id = row[student_id_idx].strip()
                name = row[name_idx].strip()
                drive_link = row[drive_link_idx].strip()
                
                # Skip empty rows
                if not student_id or not name or not drive_link:
                    failures.append({
                        "row": row_idx,
                        "student_id": student_id,
                        "reason_code": "missing_data",
                        "message": "Missing required data in row"
                    })
                    continue
                    
                # Process student
                try:
                    # Check if student already exists
                    existing_student = Student.query.get(student_id)
                    if existing_student:
                        failures.append({
                            "row": row_idx,
                            "student_id": student_id,
                            "reason_code": "db_error",
                            "message": f"Student ID {student_id} already exists"
                        })
                        continue
                    
                    # Extract file ID from drive link
                    file_id = drive_service.extract_drive_file_id(drive_link)
                    if not file_id:
                        failures.append({
                            "row": row_idx,
                            "student_id": student_id,
                            "reason_code": "invalid_link",
                            "message": f"Could not extract file ID from Drive link: {drive_link}"
                        })
                        continue
                    
                    # Download file from Drive
                    try:
                        # Create file path
                        filename = secure_filename(f"{student_id}_{uuid.uuid4()}.jpg")
                        upload_folder = current_app.config['UPLOAD_FOLDER']
                        os.makedirs(upload_folder, exist_ok=True)
                        filepath = os.path.join(upload_folder, filename)
                        
                        # Download file
                        drive_service.download_drive_file(file_id, filepath)
                        
                        # Process the image for face embedding
                        # Read the image with OpenCV
                        img = cv2.imread(filepath)
                        if img is None:
                            os.remove(filepath)
                            failures.append({
                                "row": row_idx,
                                "student_id": student_id,
                                "reason_code": "invalid_image",
                                "message": f"Could not read image file from Google Drive"
                            })
                            continue
                        
                        # Detect face and generate embedding
                        bbox, embedding = face_service.detect_and_embed_face(img)
                        
                        if embedding is None:
                            os.remove(filepath)
                            failures.append({
                                "row": row_idx,
                                "student_id": student_id,
                                "reason_code": "no_face_detected",
                                "message": f"No face detected in the image from Google Drive"
                            })
                            continue
                        
                        # Create and save student
                        student = Student(
                            student_id=student_id,
                            name=name,
                            photo_path=filepath,
                            group_id=group_id
                        )
                        student.set_embedding(embedding)
                        
                        db.session.add(student)
                        # Commit per-row so valid rows persist even if later rows fail
                        db.session.commit()
                        
                        # Add to successes
                        successes.append({
                            "row": row_idx,
                            "student_id": student_id,
                            "name": name
                        })
                        
                    except PermissionError as e:
                        failures.append({
                            "row": row_idx,
                            "student_id": student_id,
                            "reason_code": "unauthorized",
                            "message": f"Drive file not shared with service account"
                        })
                    except FileNotFoundError as e:
                        failures.append({
                            "row": row_idx,
                            "student_id": student_id,
                            "reason_code": "not_found",
                            "message": f"Drive file not found"
                        })
                    except ValueError as e:
                        failures.append({
                            "row": row_idx,
                            "student_id": student_id,
                            "reason_code": "invalid_image",
                            "message": str(e)
                        })
                    except Exception as e:
                        failures.append({
                            "row": row_idx,
                            "student_id": student_id,
                            "reason_code": "embed_error",
                            "message": f"Error embedding image: {str(e)}"
                        })
                
                except Exception as e:
                    current_app.logger.error(f"Error processing student {student_id} in row {row_idx}: {str(e)}")
                    failures.append({
                        "row": row_idx,
                        "student_id": student_id,
                        "reason_code": "db_error",
                        "message": f"Database error: {str(e)}"
                    })
            
            # Return results
            return jsonify({
                "successes": successes,
                "failures": failures
            }), 200
            
        except Exception as e:
            current_app.logger.error(f"Error processing CSV: {str(e)}")
            return jsonify({
                "success": False,
                "message": f"Error processing CSV file: {str(e)}"
            }), 500
            
    except Exception as e:
        current_app.logger.error(f"Global error in bulk import: {str(e)}")
        return jsonify({
            "success": False,
            "message": f"Error processing CSV file: {str(e)}"
        }), 500

# (rest of the file below this section remains unchanged)

@student_bp.route('/groups/<int:group_id>/students', methods=['GET'])
@admin_required()
def get_students_by_group(group_id):
    """Get all students in a group"""
    try:
        # Log the request
        current_app.logger.info(f"Fetching students for group {group_id}")
        
        # Check if group exists
        group = Group.query.get(group_id)
        if not group:
            current_app.logger.warning(f"Group with ID {group_id} not found")
            return jsonify({"error": f"Group with ID {group_id} not found"}), 404
        
        # Skip face service initialization
        # This is where errors occur if the face recognition model has issues
        
        # Get students - log how many we found
        students = Student.query.filter_by(group_id=group_id).all()
        current_app.logger.info(f"Found {len(students)} students for group {group_id}")
        
        # Manually construct student dicts to avoid any potential errors
        student_dicts = []
        for student in students:
            try:
                student_dict = {
                    'student_id': student.student_id,
                    'name': student.name,
                    'group_id': student.group_id,
                    'created_at': student.created_at.isoformat() if student.created_at else None
                }
                
                # Safely add photo_url if it exists
                if hasattr(student, 'photo_path') and student.photo_path:
                    try:
                        student_dict['photo_url'] = f"/uploads/{os.path.basename(student.photo_path)}"
                    except Exception as e:
                        current_app.logger.error(f"Error processing photo path for student {student.student_id}: {str(e)}")
                        student_dict['photo_url'] = None
                else:
                    student_dict['photo_url'] = None
                
                student_dicts.append(student_dict)
            except Exception as e:
                current_app.logger.error(f"Error processing student {student.student_id}: {str(e)}")
                # Continue processing other students
                continue
        
        response_data = {
            "group": {
                'id': group.id,
                'name': group.name,
                'student_count': len(students)
            },
            "students": student_dicts
        }
        
        return jsonify(response_data), 200
    except Exception as e:
        current_app.logger.error(f"Error fetching students for group {group_id}: {str(e)}")
        import traceback
        current_app.logger.error(traceback.format_exc())
        return jsonify({"error": "An unexpected error occurred", "details": str(e)}), 500

# Delete a student
@student_bp.route('/<string:student_id>', methods=['DELETE'])
@admin_required()
def delete_student(student_id):
    """Delete a student by ID"""
    try:
        # Log the request
        current_app.logger.info(f"Deleting student with ID: {student_id}")
        
        # Find the student
        student = Student.query.get(student_id)
        if not student:
            current_app.logger.warning(f"Student with ID {student_id} not found")
            return jsonify({"error": f"Student with ID {student_id} not found"}), 404
        
        # Delete the student's photo if it exists
        if student.photo_path and os.path.exists(student.photo_path):
            try:
                os.remove(student.photo_path)
                current_app.logger.info(f"Deleted photo file: {student.photo_path}")
            except Exception as e:
                current_app.logger.warning(f"Could not delete photo file: {str(e)}")
                # Continue with deletion even if photo can't be removed
        
        # Delete the student from the database
        db.session.delete(student)
        db.session.commit()
        
        current_app.logger.info(f"Successfully deleted student with ID: {student_id}")
        return jsonify({"message": f"Student with ID {student_id} has been deleted"}), 200
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error deleting student: {str(e)}")
        import traceback
        tb = traceback.format_exc()
        current_app.logger.error(tb)
        return jsonify({"error": "An unexpected error occurred", "details": str(e)}), 500